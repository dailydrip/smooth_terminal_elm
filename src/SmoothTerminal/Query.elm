-- Do not manually edit this file, it was auto-generated by Graphqelm
-- https://github.com/dillonkearns/graphqelm


module SmoothTerminal.Query exposing (..)

import Graphqelm.Field as Field exposing (Field)
import Graphqelm.Internal.Builder.Argument as Argument exposing (Argument)
import Graphqelm.Internal.Builder.Object as Object
import Graphqelm.Internal.Encode as Encode exposing (Value)
import Graphqelm.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphqelm.OptionalArgument exposing (OptionalArgument(Absent))
import Graphqelm.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)
import SmoothTerminal.InputObject
import SmoothTerminal.Interface
import SmoothTerminal.Object
import SmoothTerminal.Scalar
import SmoothTerminal.Union


{-| Select fields to build up a top-level query. The request can be sent with
functions from `Graphqelm.Http`.
-}
selection : (a -> constructor) -> SelectionSet (a -> constructor) RootQuery
selection constructor =
    Object.selection constructor


type alias ArticleOptionalArguments =
    { slug : OptionalArgument String }


article : (ArticleOptionalArguments -> ArticleOptionalArguments) -> SelectionSet decodesTo SmoothTerminal.Union.Article -> Field (Maybe decodesTo) RootQuery
article fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { slug = Absent }

        optionalArgs =
            [ Argument.optional "slug" filledInOptionals.slug Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionField "article" optionalArgs object (identity >> Decode.nullable)


type alias ArticlesOptionalArguments =
    { page : OptionalArgument Int, perPage : OptionalArgument Int, tag : OptionalArgument String }


articles : (ArticlesOptionalArguments -> ArticlesOptionalArguments) -> SelectionSet decodesTo SmoothTerminal.Object.PaginatedArticles -> Field (Maybe decodesTo) RootQuery
articles fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { page = Absent, perPage = Absent, tag = Absent }

        optionalArgs =
            [ Argument.optional "page" filledInOptionals.page Encode.int, Argument.optional "perPage" filledInOptionals.perPage Encode.int, Argument.optional "tag" filledInOptionals.tag Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionField "articles" optionalArgs object (identity >> Decode.nullable)


type alias AuthorOptionalArguments =
    { id : OptionalArgument Int }


author : (AuthorOptionalArguments -> AuthorOptionalArguments) -> SelectionSet decodesTo SmoothTerminal.Object.Author -> Field (Maybe decodesTo) RootQuery
author fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "author" optionalArgs object (identity >> Decode.nullable)


authors : SelectionSet decodesTo SmoothTerminal.Object.Author -> Field (Maybe (List (Maybe decodesTo))) RootQuery
authors object =
    Object.selectionField "authors" [] object (identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias FirestormThreadRequiredArguments =
    { id : String }


firestormThread : FirestormThreadRequiredArguments -> SelectionSet decodesTo SmoothTerminal.Object.FirestormThread -> Field (Maybe decodesTo) RootQuery
firestormThread requiredArgs object =
    Object.selectionField "firestormThread" [ Argument.required "id" requiredArgs.id Encode.string ] object (identity >> Decode.nullable)


type alias StoriesOptionalArguments =
    { page : OptionalArgument Int, perPage : OptionalArgument Int, tag : OptionalArgument String }


stories : (StoriesOptionalArguments -> StoriesOptionalArguments) -> SelectionSet decodesTo SmoothTerminal.Object.PaginatedStories -> Field (Maybe decodesTo) RootQuery
stories fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { page = Absent, perPage = Absent, tag = Absent }

        optionalArgs =
            [ Argument.optional "page" filledInOptionals.page Encode.int, Argument.optional "perPage" filledInOptionals.perPage Encode.int, Argument.optional "tag" filledInOptionals.tag Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionField "stories" optionalArgs object (identity >> Decode.nullable)


type alias StoryRequiredArguments =
    { uid : String }


story : StoryRequiredArguments -> SelectionSet decodesTo SmoothTerminal.Object.Story -> Field (Maybe decodesTo) RootQuery
story requiredArgs object =
    Object.selectionField "story" [ Argument.required "uid" requiredArgs.uid Encode.string ] object (identity >> Decode.nullable)


tags : SelectionSet decodesTo SmoothTerminal.Object.Tag -> Field (Maybe (List (Maybe decodesTo))) RootQuery
tags object =
    Object.selectionField "tags" [] object (identity >> Decode.nullable >> Decode.list >> Decode.nullable)
